<a name="top"></a>
## Getting Started with Web.TypeScript

`Web.TypeScript` encapsulates the [MVVM](https://addyosmani.com/blog/understanding-mvvm-a-guide-for-javascript-developers/) architecture presently
powering the Site Reporter UX (the first proof-of-concept for the framework and a reference implementation used below). The plan is to continue porting 
other sites to MVVM using the framework as a baseline and expanding it along the way.

### Overview

* [Prerequisites](#prerequisites)
* [Web vs. Web.TypeScript](#webWebTypeScript)
  * [Web Setup](#webSetup)
* [Web.TypeScript Architecture](#webTypeScriptArchitecture)
  * [Core Technologies](#coreTechnologies)
  * [Running the Project](#runningTheProject)
  * [Shared vs. Area-specific](#sharedAreaSpecific)
  * [Models](#models)
      * [Repositories](#repositories)
      * [Providers](#providers)
  * [Views & ViewModels](#viewsViewModels)
      * [Templates](#templates)
      * [Controls](#controls)
      * [Views](#views)
  * [Custom Binding Handlers](#customBindingHandlers)
  * [Config](#config)
  * [Styles](#styles)
  * [Utilities](#utilities)
  * [Samples](#samples)
  * [Tests](#tests)
  * [Known-needed improvements](#improvements)

<a name="prerequisites"></a>
### Prerequisites [[top]](#top)

You need the following to sync and build the new Web.TypeScript project in IEPortal:

* [Visual Studio 2015 (>= Update 2)](https://www.visualstudio.com/en-us/news/vs2015-update2-vs.aspx)

<a name="webWebTypeScript"></a>
### Web vs. Web.TypeScript [[top]](#top)
Web is still the project used to package and deploy IEPortal web code. `Web.TypeScript` creates a package ([`IEPortal.Web.TypeScript`](https://microsoft.visualstudio.com/EdgeES/_apps/hub/ms.feed.feed-hub?feedName=WPT.WPS&protocolType=NuGet&packageName=ieportal.web.typescript))
which is published to the WPT.WPS NuGet feed and imported as a dependency of the `Web` project.

TypeScript generates JavaScript files from TS files. These, along with CSS, are copied into the package using the same folder structure that exists in `Web`: `Areas\(AreaName)\`. The content in the package is
extracted and applied to the root of the `Web` project. `Areas\Shared` follows a different internal folder structure than non-shared areas (e.g. all the non-shared folders place the JS and CSS in the package 
into a `Content` sub-folder, which adheres to the existing setup of most areas in `Web`)

The generated JS files are included in the `Web` project (via the csproj) to ensure that they are copied as part of the output when `Web` is packaged and deployed. Presently, the files
are dummy placeholders and the directories w/generated JS files from TS are added to the `.gitignore` file so when the package updates, the changes don't trigger versioning but the new 
files are still deployed correctly.

**A couple things to note with this setup:**

* When generated files are added to/removed from the package, we need to be sure to include/exclude them from the project (and delete from git if removed)

The goal is that eventually all JS and CSS will be imported via the `IEPortal.Web.TypeScript` package. This can/will be done incrementally, though, as the setup
doesn't require existing sites to change.

<a name="webSetup"></a>
#### Web Setup [[top]](#top)

We'll use Site Reporter as an example of setting up an area to use content generated by `Web.TypeScript`. There are three things we need to setup:

* Ensure the version of `IEPortal.Web.TypeScript` in `packages.config` matches the version with the area files you will use
* RequireJS configuration (specified in `Areas\SiteReporter\Views\Shared\_Layout.cshtml`) to ensure the correct dependencies are loaded
* Starter modules for each page/view (specified, for example, in `Areas\SiteReporter\Views\Summary\Index.cshtml`) to ensure the view module is instantiated and bound to a page element

You can view the pages in the list above for implementation details.

**Note:** The JS files in `Web` are minified, but not obfuscated. You can apply pretty formatting to them in F12 tools for easy debugging.

<a name="webTypeScriptArchitecture"></a>
### Web.TypeScript Architecture [[top]](#top)

This project is split into different areas, particularly the TypeScript, to ensure quality engineering practices (e.g. open/closed, single-responsibility,
testable, etc.) are built in and the framework is maintainable and able to be built upon for all of IEPortal.

These sections cover the core technologies underpinning the framework, and provide an overview of how the modules are split up and mapped to MVVM.

<a name="coreTechnologies"></a>
#### Core Technologies [[top]](#top)

A handful of technologies play key roles in the MVVM setup and maintainability of the framework.

* [Knockout](http://knockoutjs.com/): this is the data binding and templating engine used by all the views, templates, and controls. It's how we go from
raw JSON objects returned our Web API endpoints to an interactable UI powered by, and state-bound to, that data.
* [TypeScript](https://www.typescriptlang.org/): this language is a typed superset of JavaScript that compiles to plain JavaScript. We write in `.ts` files, and
they generate `.js` files on save and build. IntelliSense, compile-time error detection, and type alignment with our APIs are key benefits to using TypeScript.
* [RequireJS](http://requirejs.org/): this is an [AMD](http://requirejs.org/docs/whyamd.html) module loader which enables us to use only the pieces of JS code
we need on demand. This saves us load time, reduces file size, and enables us to split the code into modules and manage
dependency inclusion for those modules (rough analogy: `require` = C# `import`)
* [JQuery](http://jquery.com/): well-known and loved, we use JQuery for standard DOM interactions, and also [deferred objects](https://api.jquery.com/category/deferred-object/) 
used for async data loading and dependency-based, incremental UI rendering.
* [QUnit](https://qunitjs.com/): all unit tests are written and executed via the QUnit testing framework. The tests are run at build time by 
[Chutzpah](https://github.com/mmanela/chutzpah).
* [Indigo CSS](http://edgecore.azurewebsites.net/): the goal with the controls, views, and templates is to adhere to Edge Indigo styles and conventions. This is done 
so nearly in all instances, except where some CSS is needed to stitch controls together. But by and large, nearly all of the CSS for any UI comes from the 
Indigo library, not from the Web.TypeScript project.

<a name="runningTheProject"></a>
#### Running the Project [[top]](#top)

If it's not, set `Web.TypeScript` as the startup project and hit F5. This will load the `Index.html` file in the root, which provides quick access to the
sample and test pages for Controls and Views. 

<a name="sharedAreaSpecific"></a>
#### Shared vs. Area-specific [[top]](#top)

The framework is split into `Areas\Shared` and then an area per IEPortal area (e.g. `Areas\SiteReporter`). The goal is to keep as many modules in the shared space
as possible for reuse across all our areas (for implementation efficiency, fast load times, cache optimization, etc.)

That said, many aspects like views, repositories, and providers are specific to a given area as data and UI are tailored to the purpose of the area.

Within those areas, though, much reuse is possible through controls, base classes, and utilities.

**Important note about `require` statements for shared vs. area-specific modules**:

* When requiring a shared module, reference it using an absolute, web-root-relative path, e.g. `require("Areas/Shared/Views/Base.View");`
* When requiring an area-specific module, reference it using a relative path, e.g. `require("../Data/Repositories/BugsForTag.Repository");`

This is an optimal convention given the `Areas\Shared` path will be the same for all areas (a global, essentially); and also that specific areas tend
to nest the emitted JavaScript in a `Content\js` folder. To avoid having to include that extra path data in a `require` statement, the `Areas\Shared` space breaks
from the `Content\js` convention and puts the JS files in the root directory; and the area-specific paths assume the root is `Content\js` and are relative to it.

<a name="models"></a>
#### Models [[top]](#top)

These modules map to the "Model" part of MVVM, that is the data that is both an input to and output of the view and viewmodel. 

For the sake of separation of concerns, models have been split into two types: repositories and providers.

<a name="repositories"></a>
##### Repositories [[top]](#top)

Repositories map directly to a data type returned from a data source, e.g. an API endpoint. They handle configuring and making the data request, defining
the Data Transfer Object (DTO) type, and resolving the `load` promise once the data is successfully received.

They are the only way to fetch remote data and serve to decouple that task from all other components in the framework. This lets us easily swap out data
sources (assuming the DTO types are consistent).

<a name="providers"></a>
##### Providers [[top]](#top)

Providers act as an "anticorruption layer", ensuring the consistency of data that exists within the views and viewmodels. They wrap repositories and translate the
DTO types into `ViewModelData` types via APIs consumed by and bound to a view or control.

They abstract knowledge of DTO types and transformations away from all other components in the framework, enabling us to change DTO types with isolatable impact
to the overall system.

<a name="viewsViewModels"></a>
#### Views & ViewModels [[top]](#top)

These modules map to the "View" and "ViewModel" parts of MVVM. Together they define the UI, bind data to it, and manage its state.

<a name="templates"></a>
##### Templates [[top]](#top)

Templates are the "View" part of MVVM, and are implemented as HTML snippets mixed with Knockout data bindings. They're defined using TypeScript/ES6 
[template strings](https://basarat.gitbooks.io/typescript/content/docs/template-strings.html), and offer an easy way to interpolate values.

Given they're still JavaScript modules (vs. HTML files), we do lose syntax highlighting/checking and code completion. However, template strings enable multi-line 
templates without awkward concatenation.

Both Controls and Views use templates to define UI and data bindings.

<a name="controls"></a>
##### Controls [[top]](#top)

Controls are one of two viewmodel components in the framework, the other being Views. Each control has a `ViewModel` and `Widget` class, which are responsible
for encapsulating and maintaining the state of an associated view (template). A `Widget` encapsulates and responds to changes in a `ViewModel`, and also maintains 
state for the overall control that is important but separate from the data in the `ViewModel`. `ViewModel` data is separated so it can be easily instantiated from
and serialized into `ViewModelData` which is in turn used and understood within the Repository/Provider layer.

Controls can be singular or composite. An example of a singular control is a `Button` or a `Select` dropdown. An example of a composite control is a `Filter`, which
uses the `Button` and `Select` controls to render and manage its UI.

<a name="views"></a>
##### Views [[top]](#top)

A `View` is like a control in structure, but specialized in that it represents the entire interactable/visible UI by compositing controls, and manages data interactions
to populate those controls. They're also associated 1:1 with a .NET MVC View (e.g. `Areas\SiteReporter\Views\Summary.View.ts` in `Web.TypeScript` 
is instantiated by `Areas\SiteReporter\Views\Summary\Index.cshtml`).

Metaphorically, Controls are legos, and Views compose those legos into usable structures (UI). 

By implementing Views as disposable controls, we move closer to a single-page-style application where we use JavaScript to entirely compose the portal UI.

<a name="customBindingHandlers"></a>
#### Custom Binding Handlers [[top]](#top)

Each Control has a custom binding handler that can be used on an element to turn it into that control. For instance, to bind a button to a button element,
you can do this: 

`<button data-bind="wpsButton: viewModelData"></button>`

When `ko.applyBindings` is called on the element, the value provided for `viewModelData` (which will be of type `Button.IViewModelData`) will be
passed to a new'd up `Button.Widget`.

This is functionally equivalent to this:

`<button id="myButton"></button>`

`new Button.Widget($("#myButton"))`

The custom binding handler acts as a quick way to bind nested Controls in a template by passing values inside the parent `ViewModelData`. This means you can skip 
explicitly new'ing up all the controls in the parent `Widget`.

Given that `ViewModelData` classes are used to instantiate a `Widget`, and plain data types (not observables) are used in those classes, this leads to the question of how
one can access the observables created by the `Widget` to control the UI. That's the point of MVVM, after all, right?! It is indeed. Accessing the observable values can
be done in one of two ways, from easy to somewhat-less-easy based on how you create the `Widget`:

* If you new-up the `Widget` class explicitly and assign it to say `var foo`, you can access the viewmodel via `foo.viewModel`. 
* If you new-up the `Widget` class via a custom binding handler (using the `Button` example above), you can access the viewmodel by calling 
`ko.dataFor($("#myButton")[0])`.

<a name="config"></a>
#### Config [[top]](#top)

Config files are like other config files--they contain "global" constants like strings, endpoints, defaults, etc. 

There are also debug flags used to load different configurations based on hosting location (e.g. local, portal local, or portal production). This is
done by inspecting the `window.location.href` property 

<a name="styles"></a>
#### Styles [[top]](#top)

Styles are copied over as part of package creation/deployment. They live in `Areas\(Area)\Styles` in `Web.TypeScript`, and are copied to two locations 
in the package:

* If it's `Areas\Shared`, copied to `Areas\Shared\Styles`
* If it's any other area, copied to `Areas\(Area)\Content\css`

<a name="utilities"></a>
#### Utilities [[top]](#top)

There are a handful of utilitie classes used for generic things like making requests, navigating to URLs, etc. Many more will undoubtedly be added
as we continue to build on this framework.

<a name="samples"></a>
#### Samples [[top]](#top)

Samples enable us to do 90%+ of our development locally, outside the Portal. This reduces page reload times and roundtrip costs when changes are made. Using
[Mockjax](https://github.com/jakerella/jquery-mockjax), we can also mock (for samples *and* tests) network/API requests which enables local development
even when data is necessary to fully express a Control or View.

These typically show a baseline and other common implementations/states for a Control or View, as well as the module rendered via its custom binding handler.

The goal of the sample is to demonstrate how the module would appear in the portal, so things like the Indigo library and other CSS/JS libraries are used in
the sample pages to achieve that.

<a name="tests"></a>
#### Tests [[top]](#top)

As mentioned earlier, tests are UI-style unit tests implemented using QUnit and run via Chutzpah. "UI-style" means not every function of every class is tested.
The goal is functional coverage in support of possible UI scenarios. So most tests are done from a user-interaction POV.

<a name="improvements"></a>
#### Known-needed improvements [[top]](#top)

* Commenting of all public properties
* Move Base.View to extend Controls\Base (it's a control after-all, just specialized)
* Unit tests for uncovered modules (controls, repositories, providers, views, utilities, etc.)
* DRY out mock data into test/sample utilities
* Implement URL changign when filters or other UI states change that impact URL (so that we can deep-link)
* *Many more to add, I'm sure!*